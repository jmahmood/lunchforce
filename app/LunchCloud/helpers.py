import datetime
import logging
import random
import uuid
from types import FunctionType
from typing import List, Dict, Tuple, Iterable

import names

from LunchCloud.models import Profile, LunchAppointment


class AutoInviteBot:
    """Used by cupid to generate a set of invitations for people with an open lunch on a specific date."""

    def __init__(self, dt: str):
        self.date = date_from_string(dt)
        self.creator = Profile.objects.get(pk=1)

        self.people = Profile.objects.filter(
            availability__frm__year=self.date.year,
            availability__frm__month=self.date.month,
            availability__frm__day=self.date.day).exclude(
            confirmed__event_date__year=self.date.year,
            confirmed__event_date_month=self.date.month,
            confirmed__event_date__day=self.date.day)

        self.all_locations = set([l for locations in self.people.locations.all() for l in locations])

        """Lunch appointments that already exist for the date (which we may wish to add people to)"""
        self.preexisting_lunch_appointments = LunchAppointment.objects.filter(
            event_date=self.date).filter(general_area__in=self.all_locations)

        """Creates a list of all recent appointments / lunches that someone went on.
        This is used to de-prioritize future lunches so other people can have a turn """
        __recent_lunch_appointments = LunchAppointment.objects.filter(
            event_date__gte=(datetime.datetime.now() - datetime.timedelta(days=14)).date()).filter(
            event_date__lte=datetime.date.today()).filter(
            attendees__in=self.people)

        self.recent_historical_appointments = {p: __recent_lunch_appointments.filter(attendees__in=p)
                                               for p in self.people}

    def __call__(self, *args, **kwargs):
        for location in self.all_locations:
            lunch_appointment_groups = self.generate_appointment_groups(location)
            self.save_new_lunch_appointments(
                [lag for lag in lunch_appointment_groups if lag.original is None], location)
            self.update_old_lunch_appointments(
                [lag for lag in lunch_appointment_groups if lag.original is not None])

    def update_old_lunch_appointments(self, preexisting_lunch_appointment_groups):
        """Accepts a list of groups that have had a change in their invitees"""
        for g in preexisting_lunch_appointment_groups:
            profile_external_ids = [p.id for p in g.people]
            to_add = self.people.filter(external_id__in=profile_external_ids)
            if to_add.count() > 0:
                g.original.invitees.add(*to_add)
                self.people = self.people.exclude(profile__in=to_add)

    def save_new_lunch_appointments(self, new_lunch_appointment_groups, location):
        """Generates completely new Lunch Appointments for new requests."""
        return LunchAppointment.objects.bulk_create([
                LunchAppointment(
                    event_date=self.date,
                    invitees=[self.people.filter(external_id=p.id) for p in g.people],
                    min_attendees=2,
                    max_attendees=5,
                    title='Lunch in {0} on {1}'.format(location.name, self.date),
                    description='Autogenerated event',
                    general_area=location,
                    creator=self.creator,
                    is_private=False,
                    status='Proposed'
                )
                for g in new_lunch_appointment_groups
            ])

    def generate_appointment_groups(self, location):
        """Acts as a bridge between data stored in the data model and the make_groups function"""
        people = self.people.filter(locations__in=location)
        preexisting_lunch_appointments = self.preexisting_lunch_appointments.filter(general_area=location)

        lunch_people = [
            LunchPerson.factory(p, self.recent_historical_appointments)
            for p in people
        ]

        lunch_appointment_groups = [
            LunchAppointmentGroup.factory(g, self.recent_historical_appointments)
            for g in preexisting_lunch_appointments
        ]

        return make_groups(lunch_people, lunch_appointment_groups)


def attendee_meeting_dict(recent_lunch_meetings: {LunchAppointment}) -> {str: LunchAppointment}:
    ret = dict.fromkeys([attendee.external_id for meeting in recent_lunch_meetings
                         for attendee in meeting.attendees.all()], [])

    for a, m in [(attendee, meeting) for meeting in recent_lunch_meetings for attendee in meeting.attendees.all()]:
        ret[a.external_id].append(m)

    return ret


def date_from_string(dt) -> datetime.date:
    """This is only going to be used locally, so avoid the mental overhead with timezones for now."""
    y, m, d = dt.split('-')
    return datetime.date(year=int(y), month=int(m), day=int(d))


def report_on_fairness(person, all_people, context) -> str:
    """
    Generates a text report on a person who was left out of a lunch event, despite potentially having people there that
    he did not despise.
    """

    return """{0} signed up for lunch on {1} but this algo could not find him anyone.
{0} previously was matched on {2}, going out with {3}.
{0} currently hates {4}.
The people who signed up for lunch on {1} were {5}.""".format(
        person.name,
        context.usage_history,
        context.last_usage,
        ','.join(context.last_usage_partners),
        ','.join(person.hates),
        ','.join(all_people)
    )


class LunchPerson:
    """
    This is an adaptor that is used to convert a Profile object into an object that can be easily used with
    the Invitation generator

    @TODO: Can we integrate these into the profile object itself, or create a different inherited version of the
    profile object that can be used for this same purpose?
    """
    id = ''
    name = ''
    is_noob = False
    food_likes = set()
    people_met = set()
    hates = set()
    food_types = ['Japanese', 'Chinese', 'Indian', 'American', 'Hamburger', 'Pizza']
    original: Profile = None

    def __str__(self):
        return self.name

    def __init__(self, person_id, name, is_noob, food_likes, people_met, hates) -> None:
        super().__init__()
        self.id = person_id
        self.name = name
        self.is_noob = is_noob
        self.food_likes = food_likes
        self.people_met = people_met
        self.hates = hates

    def recently_met(self, person):
        """If you have recently met someone, we try to reduce the chance you meet them again."""
        if self.people_met is None or person.id not in self.people_met:
            return False
        return True

    @staticmethod
    def factory(person: Profile, recent_lunches: Dict[str, List[LunchAppointment]]):
        """Generates """
        lunch_attendees = (x.attendees.all() for x in recent_lunches.get(person.external_id, []))
        people_met: set = {attendee.external_id for attendee_l in lunch_attendees for attendee in attendee_l}

        logging.debug("""Creating a LunchPerson object.
Name: {0}
People Met: {1}""".format(person.user.username, ','.join(list(people_met))))

        lp = LunchPerson(
            person_id=person.external_id,
            name=person.user.username,
            is_noob=recent_lunches.get(person.external_id) is not None,
            food_likes=set(person.whitelist.all()),
            people_met=people_met,
            hates=None
        )

        lp.original = person
        return lp


class LunchAppointmentGroup:
    people: [LunchPerson] = []
    is_private = False
    invited = []
    original: LunchAppointment = None

    def __str__(self) -> str:
        return ', '.join(['{0} ({1})'.format(p.name, p.is_noob) for p in self.people])

    def __len__(self):
        return len(self.people)

    def __getitem__(self, item):
        return self.people[item]

    def __hash__(self):
        people: List[LunchPerson] = sorted(self.people, key=id)
        return hash(','.join([p.id for p in people]))

    def __init__(self, people=None) -> None:
        super().__init__()
        if people is None:
            self.people = []
        else:
            self.people = people

    def __iter__(self):
        self.iter_n = -1
        return self

    def __next__(self):
        self.iter_n += 1
        try:
            return self.people[self.iter_n]
        except IndexError:
            raise StopIteration

    def ids(self):
        return {p.id for p in self.people}

    def food_likes(self):
        food_likes = set(self.people[0].food_likes)
        for p in self.people:
            food_likes.intersection(p.food_likes)

        return food_likes

    def append(self, other):
        ids = [p.id for p in self.people]
        if other.id not in ids:
            self.people.append(other)

    @staticmethod
    def factory(lunch_appointment: LunchAppointment, recent_lunch_meetings):
        # convert attendees to lunch person
        ret = LunchAppointmentGroup()
        people = [LunchPerson.factory(p, recent_lunch_meetings)
                  for p in lunch_appointment.attendees.all()]
        ret.people = people
        ret.is_private = lunch_appointment.is_private
        ret.invited = [i.external_id for i in lunch_appointment.invitees.all()]
        ret.original = lunch_appointment
        return ret


def one_noob_max(person, group: LunchAppointmentGroup):
    """We want to try to limit the number of new people in each lunch group in order to allow them to pick up on
    social conventions"""
    group_noob_count = len([grp_p.is_noob for grp_p in group if grp_p.is_noob])
    logging.debug("Found {0} noobs in group {1}".format(group_noob_count, group.__str__()))
    return not person.is_noob or person.is_noob and group_noob_count == 0


def no_gate_crashing(person, group: LunchAppointmentGroup):
    """You cannot join a private meeting if you are not invited"""
    return not group.is_private or person.id in group.invited


def no_haters(person, group: LunchAppointmentGroup):
    """In the future, we will allow hatred to be """
    return person.hates is None or len(set(person.hates).intersection(group.ids())) > 0


def fairness_sort(lonely_people: Iterable[LunchPerson]):
    """
    People who are higher in priority should be closer to the front of this list, people lower in priority should be at
    the back.
    :param lonely_people:
    :return:
    """
    return sorted(lonely_people, key=lambda per: per.is_noob, reverse=True)


def recent_meetings(prsn, grp):
    """Goes through all invitees for an event and checks if you have met any of them recently.  If so, tries to push
    you into a different lunch meeting.  (Diversity)"""
    return True not in (prsn.recently_met(grp_p) for grp_p in grp)


def inviolable_rules(prsn, grp):
    """Max 4 people in an auto-generated group, no one should hate each other, and you can't be added automatically to
    a private event"""
    return len(grp) < 4 and no_haters(prsn, grp) and no_gate_crashing(prsn, grp)


class FinderBot:
    """
    Implements an algorithm to find compatible groups, or to generate new ones, for users passed to the application.
    """

    def __init__(self, people: List[LunchPerson], groups: List[LunchAppointmentGroup]) -> None:
        super().__init__()
        self.people: List[LunchPerson] = people
        self.groups: List[LunchAppointmentGroup] = groups
        self.lonely_people: List[LunchPerson] = self.filter_out_invitees()
        self.lonely_people: List[LunchPerson] = self.fairness_sort()
        self.nice_to_have_rules: List[Tuple[FunctionType, str, str]] = [
            (lambda prsn, grp: len(prsn.food_likes.intersection(grp.food_likes())) > 0, 'Common Interests', 'You must have a food like in common'),
            (recent_meetings, 'Freshness', 'You should be meeting new people'),
            (one_noob_max, 'Noobs!', 'Only want 1 Noob per group, if possible.')
        ]

        self.inviolable_rules: List[Tuple[FunctionType, str, str]] = [
            (lambda prsn, grp: len(grp) < 4, 'Group size', 'Groups should have 4 people max.'),
            (no_haters, 'No haters', 'You should not eat with someone you hate.'),
            (no_gate_crashing, 'Gate Crashing', 'You should not barge into a private event.')
        ]

        self.__iter = 0

    def __call__(self, *args, **kwargs) -> Tuple[List[LunchAppointmentGroup], List[LunchPerson]]:
        """
        Calculates the groups that can be done and returns the list, along with people who could not be matched.

        :param args:
        :param kwargs:
        :return:
        """
        if self.__already_called():
            raise InterruptedError('This already been run.')
        while self.should_keep_looking():
            [self.add_to_compatible_group(x) for x in self.lonely_people]  # Return product is null; only interested in side effect.  Haskellers beware.
            self.groups = self.filter_out_invalid_groups()
            self.lonely_people = self.filter_out_invitees()

        return self.groups, self.lonely_people

    def __already_called(self) -> bool:
        """
        Prevents the FinderBot object from being executed more than once.

        :return:
        """
        self.__iter += 1
        return self.__iter > 1

    def should_keep_looking(self) -> bool:
        """
        Examines the number of lonely people and removes optional rules as necessary to seat them.

        If True, it means there are still more lonely people and we can still reduce the number of rules we have.

        :return:
        """
        if len(self.lonely_people) == 0:
            logging.debug("No lonely people.  Returning.")
            return False
        if self.__iter > 1:
            try:
                self.nice_to_have_rules.pop()
                logging.debug("Relaxing rules.")
            except IndexError:
                logging.debug("No more rules to relax.")
                return False

        self.__iter += 1
        return True

    def add_to_compatible_group(self, p: LunchPerson):
        """
        Sorts compatible groups by the number of attendees and adds the lonely person to the smallest lunch possible.

        :param p:
        :return:
        """
        compatible_groups = sorted(
            [g for g in self.groups if self.is_compatible(p, g)],
            key=lambda c_gx: len(c_gx.people))

        try:
            compatible_groups[0].append(p)
        except IndexError:
            logging.debug("No compatible groups found, creating new one.")
            self.groups.append(LunchAppointmentGroup([p]))

    def filter_out_invalid_groups(self) -> List[LunchAppointmentGroup]:
        """Private groups can have only one person invited, as they may be assembling people.
        All public groups must have more than 1 person invited."""
        return [group for group in self.groups if group.is_private or len(group.people) > 1]

    def filter_out_invitees(self) -> List[LunchPerson]:
        """We do not automatically add people to multiple events."""
        already_invited = [person.id for g in self.groups for person in g.people]
        return fairness_sort([p for p in self.people if p.id not in already_invited])

    def fairness_sort(self) -> List[LunchPerson]:
        """We do not automatically add people to multiple events."""
        return sorted(self.lonely_people, key=lambda per: per.is_noob, reverse=True)

    def is_compatible(self, person: LunchPerson, grp: LunchAppointmentGroup) -> bool:
        rule_format = """{0}: {1} ({2})\n"""
        report_card = "\nChecking compatibility of {0} (is noob: {2}) for {1}\n".format(str(person), str(grp), person.is_noob)
        ret = True

        for rule, name, explanation in self.inviolable_rules + self.nice_to_have_rules:
            compatible = rule(person, grp)
            report_card += rule_format.format(name, compatible, explanation)
            if not compatible:
                ret = False

        report_card += "\nResult: {0} ---\n".format(ret)
        logging.info(report_card)

        return ret


def make_groups(people: [LunchPerson], groups: [LunchAppointmentGroup] = None) -> List[LunchAppointmentGroup]:
    """
    Data passed must be for a single location, and you must filter that before sending here.
    It will ignore locations otherwise.

    Based on Greedy Bin Packing Algorithm
        inviolable rules for all groups:
        -> You cannot go out with someone you hate.
        -> max size 4 (min size 2)
        -> Cannot join a private group unless you are invited.

        nice to have:
        -> If you can join more than one group, join the smallest group there is.
        -> everyone has at least one type of food they like in common
        -> we haven't recently (within 2 months) met each other
        -> only one new person per group

    :param people:
    :param groups:
    :return:
    """

    nice_to_have = [lambda prsn, grp: len(prsn.food_likes.intersection(grp.food_likes())) > 0,
                    # ^^ You share a liked food with everyone in the group.
                    recent_meetings,
                    # ^^ You haven't recently met anyone in the group.
                    one_noob_max]
    nice_to_have_rule_names = ['Share a liked food', 'haven\'t met anyone recently', 'one noob max']

    if groups is None:
        groups: [LunchAppointmentGroup] = []

    # Filter out people who have already been invited to an appointment on that day.
    already_invited = [person.id for g in groups for person in g.people]
    lonely_people = list([p for p in people if p.id not in already_invited])
    lonely_people = fairness_sort(lonely_people)

    can_loosen_regulations_further = True

    # Once you run out of lonely people, or rules to overlook, return the results we have.
    while len(lonely_people) > 0 and can_loosen_regulations_further:
        for p in lonely_people:
            compatible_groups = []
            logging.debug("Searching through groups for {0}".format(p.name))
            logging.debug("Current groups available: {0}".format('--'.join([g.__str__() for g in groups])))
            for g in groups:
                compatible = inviolable_rules(p, g)  # This must, at all times, be true.
                logging.debug("Important rules passed? {0}".format(compatible))
                if not compatible:
                    continue

                for i, r in enumerate(nice_to_have):
                    nice_to_have_result = nice_to_have[i](p, g)
                    #  These nice-to-have rules slowly become less important for more and more desperate people.
                    logging.debug("Nice to have rule ({1}) passed? {0}".format(nice_to_have_result,
                                                                               nice_to_have_rule_names[i]))
                    compatible = compatible and nice_to_have_result

                if compatible:
                    logging.debug("Added to group: {0}".format(g.__str__()))
                    compatible_groups.append(g)

            if len(compatible_groups) > 0:
                logging.debug("Appending to compatible group.")
                compatible_groups.sort(key=lambda c_gx: len(c_gx.people))
                compatible_groups[0].append(p)  # Append to smallest compatible group
            else:
                logging.debug("No compatible groups; creating new one.")
                groups.append(LunchAppointmentGroup([p]))

        valid_groups = [grp for grp in groups if len(grp.people) > 1]
        invalid_groups = [grp for grp in groups if grp not in valid_groups]

        # filter out the people who were not added to a group successfully.
        lonely_people = [p[0] for p in invalid_groups]
        groups = valid_groups
        logging.debug('Lonely People: ' ','.join(lp.__str__() for lp in lonely_people))

        try:
            nice_to_have.pop()  # get rid of a nice-to-have rule and let's try again.
        except IndexError:
            can_loosen_regulations_further = False

    logging.debug("Current groups available: {0}".format('--'.join([g.__str__() for g in groups])))
    # Why are you lonely, little man?  Send a mail to explain how it is hard to match people who have
    # impossible requirements.
    return groups
